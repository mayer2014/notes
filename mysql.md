和其他数据库系统相比，MySQL有点与众不同，它最重要、最与众不同的特性是它的存储引擎架构，这种架构的设计将查询处理与其他任务系统和数据的存储、提取相分离。这种处理和存储分离的设计可以在使用时根据性能、特性，以及其他需求来选择数据存储的方式。

1.1 MySQL逻辑架构
第一层的架构是连接处理、授权认证、安全等扽；第二次结构是MySQL核心功能，包含查询解析、分析、优化、缓存以及所有的内置函数，所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等；第三层架构是存储引擎，存储引擎负责MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信，这些接口屏蔽了不同存储引擎之间的差异，不同的存储引擎之间也不会进行通信，而只是简单地响应上层服务器的请求。
1.1.1 连接管理与安全性
每个客户端连接都会在服务器进程中拥有一个线程，单个连接的查询只会在其单独的线程中执行，服务器会负责缓存线程，因此不需要为每一个新建的连接创建或销毁线程，MySQL5.5之后的版本提供了一个API，支持线程池插件，可以使用线程池中少量的线程来服务大量的连接。
1.1.2 优化与查询
MySQL会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询，决定表的读取顺序，以及选择合适的索引等。用户可以通过特殊的关键字提示（hint）优化器，影响它的决策过程。也可以请求优化器解释（explain）优化过程的各个因素，使用户可以知道服务器是如何进行优化决策的，并提供一个参考基准，便于用户重构查询和schema、修改相关配置。
优化器并不关心表使用的是什么存储引擎，但存储引擎对优化查询是有影响的。优化器会请求存储引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息等。
对于SELECT语句，在解析之前，服务器会先检查查询缓存（Query Cache），如果能在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行整个过程，而是直接返回查询缓存中的结果集。

1.2 并发控制
无论何时，只要有多个查询在同一时刻修改数据，都会产生并发控制问题。MySQL存在两个层面上的并发控制：服务器层和存储引擎层。
1.2.1 读写锁
读锁也叫共享锁，相互之间不阻塞，多个客户在同一时刻可以同时读取同一资源，互不干扰；写锁也叫排他锁，会阻塞其他的写锁和读锁，只有这样，才能保证在给定的时间里只有一个用户能执行写入，并防止其他用户读取正在写入的统一资源。
1.2.2 锁粒度
一种提高共享资源并发性的方式就是让锁定对象更具选择性，尽量只锁定需要修改的部分数据，锁定的数据量越少，系统的并发程度就越高，但是加锁也需要消耗资源。锁的各种操作，获得锁、检查锁是否已经解除、释放锁等都会增加系统开销。
所谓的锁策略，就是在锁的开销和数据的安全性之间寻求平衡。大多数商业数据库系统没有提供更多的选择，一般都是在表上施加行级锁，并以各种复杂的方式来实现，而MySQL则提供了多种选择。每种MySQL存储引擎都可以实现自己的锁策略和锁粒度。
表锁是MYSQL中最基本的锁策略，开销最小。  在特定场景中表锁也可能有良好的性能，例如READ LOCAL表锁支持某些类型的并发操作。另外，写锁也比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁锁队列的前面，尽管存储引擎可以管理自己的锁，MySQL本身还是会使用各种的有效的表锁来实现不同的目的。例如，服务器会为ALTER TABLE之类的语句使用表锁而忽略存储引擎的锁机制。
行级锁可以最大程度地支持并发处理，同时也带来了最大的锁开销，行级锁只在存储引擎层实现，服务器层完全不了解存储引擎中的锁实现。
页级锁介于表锁和行锁之间，每次锁定相邻的一组数据，BDB引擎使用页级锁。

1.3 事务
事务是一组原子性的SQL查询，或者说一个独立的工作单元。一个运行良好的事务处理系统必须具备ACID标准特征。
原子性：一个事务被视为一个不可分割的最小工作单位，要是全部成功提交，要么全部失败回滚。
一致性：数据库总是从一个一致性的状态转换到另一个一致性的状态，以便维护数据的完整性。
隔离性：通常来说，一个事务所做的修改在最终提交前，对其他事务是不可见的，但也受隔离级别影响。
持久性：一旦事务提交，则其修改会永久保存到数据库中。
事务处理过程增加了额外的安全性，也增加了额外的系统开销，对于一些不需要事务查询的应用，选择一个非事务型的存储引擎可以获得更高的性能。即使存储引擎不支持事务，也可以通过LOCK TABLE语句为应用提供一定程度的保护。
1.3.1 隔离级别
隔离级别规定了一个事务中所的修改，哪些在事务内和事务间是可见的，哪些是不可见的。较低的隔离级别通常可以执行更高的并发，系统的开销也越低。
READ UNCOMMITTED（未提交读）：事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也叫脏读。
READ COMMITTED（提交读）：在一个事务中，只能看见已提交事务所做的修改，这个级别也叫不可重复读，在一个事务中先后的两次同样的查询可能会得到不同的结果。
REPEATABLE READ（可重复读）：该级别保证了同一个事务中多次读取同样的记录的结果是一致的，但是依然无法解决幻读。所谓幻读，就是当某个事务读取某个范围内记录时，另一个事务又在该范围内插入了新的记录，再次读取时会产生幻行，仿佛插入的记录不存在一样。InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC）解决幻读问题，该隔离级别是MySQL默认的隔离级别。
SERIALIZABLE（可串行化）：最高的隔离级别，通过强制事务串行执行，避免幻读问题。SERIALIZABLE会在读取的每一行数据上加锁，所以可能导致大量的超时和锁争用问题。
1.3.2 死锁
死锁是指两个或多个事务在同一资源上相互争用，并请求锁定对方占用的资源，从而导致恶心循环的现象。为解决死锁问题，数据库系统实现了各种死锁检测和死锁超时机制，InnoDB会将持有最少行级排他锁的事务进行回滚，而不必等到查询时间达到锁等待超时自动放弃锁请求的设定。死锁发生后，只有部分或者完全回滚其中一个事务才能打破死锁，所以应用程序在设计时必须考虑如何处理死锁，大多数情况下只要重新执行因死锁回滚的事务即可。
1.3.3 事务日志
事务日志：事务日志也叫前滚日志或重做日志（redo日志），在mysql中默认以ib_logfile0，ib_logfile1名称存在,可以手工修改参数，调节开启几组日志来服务于当前mysql数据库，每开启一个事务时，会把对数据文件数据修改的物理位置或叫做偏移量记录事务日志中，以便在系统崩溃重启时，作事务重做，在系统正常时，每次checkpoint时间点，会将之前写入事务应用到数据文件中。InnoDB通过事务日志把随机IO变成顺序IO,这大大的提高了InnoDB写入时的性能.
日志缓冲(log buffer)：日志缓冲区是小型的，用于短期存储将写入磁盘上的事务日志文件的变更向量的临时区域，服务器进程不将事务直接写入事务日志文件，而是把事务先写入内存中的日志缓冲区，之后再从日志缓冲区写出到事务日志文件。因此，日志缓冲区对磁盘的一次写入是来自多个事务的一批变更向量。当会话发出commit语句时，会实时执行日志缓冲区写操作，写操作由LGWR进程完成，日志缓冲区在启动实例时分配，如果不重新启动实例，就不能在随后调整其大小。
页高速缓存：页高速缓存是linux内核实现的一种主要磁盘缓存，通过把磁盘中的数据缓存到物理内存中，把对磁盘的访问变为对物理内存的访问，从而减少对磁盘的IO操作。页高速缓存是由RAM中的物理页组成的，缓存中的每一页都对应着磁盘中的多个块（不一定连续）。每当内核开始执行一个页IO操作时，就先到高速缓存中找，这样就可以大大减少磁盘操作。 当进程修改了高速缓存里的数据时，该页就被内核标记为脏页。
缓冲池(Buffer pool)：数据库缓冲池区域是一块内存，当从磁盘上读取一个表的索引和数据页，以便对它们进行扫描或修改时，可以用缓冲池缓存它们（热数据）。缓冲池为数据库页提供工作内存和高速缓存。缓冲池通过允许从内存（而不是磁盘）中读取数据来提高数据库系统的性能。由于大多数页数据处理发生在缓冲池内，因此配置缓冲池是唯一的最为重要的调整环节。当应用程序访问表行时，数据库管理器将在缓冲池中查找包含该行的页。如果在缓冲池中找不到该页，那么数据库管理器将从磁盘中读取该页并将其放入缓冲池。然后，可以使用该数据来处理查询。
当提交一个事务时，InnoDB存储引擎把事务写入日志缓冲(log buffer),日志缓冲再把事务刷新到事务日志.，之后InnoDB存储引擎把事务写入缓冲池(Buffer pool)，多个线程在监控buffer的活动情况，出现overflow，checkpoint或commit都将导致写盘操作。
使用事务日志，存储引擎在修改表的数据时只需要把修改行为记录到磁盘的事务日志中，再修改其内存拷贝，而不用每次都将修改的数据本身持久到磁盘。事务日志采用追加的方式，因此写日志的操作是磁盘上一小块区域的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。事务日志持久后，内存修改的数据可以在后台慢慢刷回到磁盘，这种方式也叫预写式日志，修改数据需要写两次磁盘。如果修改的记录以及写进事务日志并持久化，但数据还没有写入磁盘，此时系统奔溃，存储引擎会在重启时自动恢复这部分修改的数据。
1.3.4 MySQL中的事务
MySQL提供了两种事务型的存储引擎：InnoDB和NDB Cluster。
自动提交：MySQL默认采用自动提交（AUTOCOMMIT）模式。如果不是显式地开启一个事务，每个查询都被当作一个事务提交操作。在当前连接中，可以设置AUTOCIMMIT变量来启用或禁用自动提交（SET AUTOCOMMIT = ON/OFF）。当AUTOCOMMIT=0时，所有查询都是在一个事务中，直到显式地执行COMMIT提交或者ROLLBACK回滚，该事务结束时，同时又开始了另一个新事务，修改AUTOCOMMIT对非事务型的表不会有任何影响。有一些命令，例如ALTER TABLE、LOCK TABLES在执行之前会强制执行COMMIT提交当前事务。MySQL可以通过SET TRANSACTION ISOLATION LEVEL命令来设置隔离级别，也可以只改变当前会话的隔离级别，例如SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED。
在事务中混合使用存储引擎：MySQL服务器层不管理事务，事务由下层的存储引擎实现。如果在事务中混合使用了事务型和非事务型的表，正常提交不会有任何问题，但是回滚时非事务型的表上的变更无法撤消，所以在同一个事务中使用多中存储引擎是不可靠的。
1.事务在加锁时有多种方式：
 
一次性锁协议，事务开始时，即一次性申请所有的锁，之后不会再申请任何锁，如果其中某个锁不可用，则整个申请就不成功，事务就不会执行，在事务尾端，一次性释放所有的锁。一次性锁协议不会产生死锁的问题，但事务的并发度不高。
 
两阶段锁协议，整个事务分为两个阶段，前一个阶段为加锁，后一个阶段为解锁。在加锁阶段，事务只能加锁，也可以操作数据，但不能解锁，直到事务释放第一个锁，就进入解锁阶段，此过程中事务只能解锁，也可以操作数据，不能再加锁。两阶段锁协议使得事务具有较高的并发度，因为解锁不必发生在事务结尾。它的不足是没有解决死锁的问题，因为它在加锁阶段没有顺序要求。如两个事务分别申请了A, B锁，接着又申请对方的锁，此时进入死锁状态。
 
树形协议，假设数据项的集合满足一个偏序关系，访问数据项必须按此偏序关系的先后进行。如di->dj，则要想访问dj，必须先访问di。这种偏序关系导出一个有向无环图(DAG)，因此称为树形协议。树形协议的规则有：
树形协议只有独占锁；
事务T第一次加锁可以对任何数据项进行；
此后，事务T对数据项Q的加锁前提是持有Q的父亲数据项的锁；
对数据项的解锁可以随时进行；
数据项被事务T加锁并解锁之后，就不能再被事务T加锁。
树形协议的优点是并发度好，因为可以较早地解锁。并且没有死锁，因为其加锁都是顺序进行的。
缺点是对不需要访问的数据进行不必要的加锁。
 
时间戳排序协议，每个事务都有一个唯一的时间戳，也就是其进入系统的时间。时间戳有大小之分，如果事务Ti比Tj先进入系统，则TS(Ti)<TS(Tj)。对于每个数据项Q，有两个时间戳与其绑定：一个是W-TS(Q)，表示最近一次写数据项Q的事务的时间戳；一个是R-TS(Q)，表示最近一次读数据项Q的事务的时间戳。Thomas协议是对时间戳排序协议的改进，具体内容如下：
若事务Ti发起一个write(Q)，则
如果TS(Ti)<R-TS(Q)，则表明Ti准备写的值还没来得及写入，Q就提前被读取了，所以Ti的write(Q)操作被拒绝，并且事务Ti被回滚。
如果TS(Ti)<W-TS(Q)，表明Ti写的值已过期，比它更新的值已经写到Q上，所以Ti的write(Q)操作被拒绝。
剩下的情况，write(Q)操作被允许。
 
事务在加锁时存在粒度的区别：
如数据库锁，表锁，行锁，字段锁，页锁等。不同的数据库支持的锁粒度不同，BerkeleyDB支持页锁，即对数据项所在的内存页加锁。
InnoDB采用两阶段锁协议。在事务执行过程中，随时都可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁是在同一时刻被释放。InnoDB会根据隔离级别在需要的时候自动锁定（隐式锁定），另外也支持显示锁定：SELECT ... LOCK IN SHARE MODE和SELECT ... FOR UPDATE。MySQL也支持LOCK TABLES和UNLOCK TABLES语句，这是在服务器层实现的，和存储引擎无关。除非事务中禁用AUTOCOMMIT，否则尽量不要使用LOCK TABLES，因为LOCK TABLES和事务之间相互影响的话，情况会变得非常复杂。
多版本并发控制：
锁是针对集中式数据管理设计的，缺点是降低了事务的并发，并且锁本身有开销。在分布式系统，尤其是读多写少的系统中，采用多版本机制更合适。每个数据项都有多个副本，每个副本都有一个时间戳，根据多版本并发控制协议(MVCC)维护各个版本。
 
MVCC又称为乐观锁，它在读取数据项时，不加锁；在更新数据项时，直到最后要提交时，才会加锁。这与CAS(Compare and Swap)的机制很类似，为了提高并发度，它更新数据前，会将数据拷贝一份，进行一系列修改，并且拷贝的同时，会记录当前的版本号(时间戳)，当修改完毕，即将提交时，再检查此时的版本号是否与刚才记录的一致，如果不一致，则表明数据项被其他事务修改，当前事务的修改被取消。否则，正式提交修改，并增加版本号。
与MVCC相对，基于锁的并发控制机制称为悲观锁，因为它认为其他事务修改自己正在使用的数据项的概率很高，因此对数据项加锁以阻塞其他事务的读和写。

